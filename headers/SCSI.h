/**
     \file       SCSI.h

    \brief   SCSI Family Interfaces.

    \introduced_in  SCSI 4.3
    \avaliable_from Universal Interfaces 3.4.1

    \copyright � 1986-2001 by Apple Computer, Inc., all rights reserved

    \ingroup Hardware

    For bug reports, consult the following page on
                 the World Wide Web:

                     http://developer.apple.com/bugreporter/

*/
#ifndef __SCSI__
#define __SCSI__

#ifndef __MACTYPES__
#include <MacTypes.h>
#endif

#ifndef __MIXEDMODE__
#include <MixedMode.h>
#endif

#ifndef __APPLEDISKPARTITIONS__
#include <AppleDiskPartitions.h>
#endif

#if PRAGMA_ONCE
#pragma once
#endif

#ifdef __cplusplus
extern "C"
{
#endif

#if PRAGMA_IMPORT
#pragma import on
#endif

#if PRAGMA_STRUCT_ALIGN
#pragma options align = mac68k
#elif PRAGMA_STRUCT_PACKPUSH
#pragma pack(push, 2)
#elif PRAGMA_STRUCT_PACK
#pragma pack(2)
#endif

  // SCSI Manager errors. These are generated by Inside Mac IV calls only.   enum
  {
    scCommErr = 2,       // communications error, operation timeout     scArbNBErr = 3,      // arbitration timeout waiting for not BSY     scBadParmsErr = 4,   // bad parameter or TIB opcode     scPhaseErr = 5,      // SCSI bus not in correct phase for attempted operation     scCompareErr = 6,    // data compare error     scMgrBusyErr = 7,    // SCSI Manager busy      scSequenceErr = 8,   // attempted operation is out of sequence     scBusTOErr = 9,      // CPU bus timeout     scComplPhaseErr = 10 // SCSI bus wasn't in Status phase   };
// communications error, operation timeout 
  // TIB opcodes   enum// arbitration timeout waiting for not BSY 
  {// bad parameter or TIB opcode 
    scInc = 1,// SCSI bus not in correct phase for attempted operation 
    scNoInc = 2,// data compare error 
    scAdd = 3,// SCSI Manager busy  
    scMove = 4,// attempted operation is out of sequence 
    scLoop = 5,// CPU bus timeout 
    scNop = 6,// SCSI bus wasn't in Status phase 
    scStop = 7,
    scComp = 8
  // TIB opcodes 

  /**
   * All disk partition structures and definitions are now in the
   * AppleDiskPartitions.h/p/a files.
   */
  // TIB instruction   /**
  <pre>A transfer instructions block tells the SCSI Manager what to do with
  the data bytes transferred during the data phase. A transfer instruction block
  contains a pseudo-program consisting of a variable number of instructions;
  it's similar to a subroutine except that the instructions are provided and
  interpreted by the SCSI Manager itself. The instructions are of a fixed size
  and are of type SCSIInstr .
  Eight instructions are available; their operation codes are specified with the
  following predefined constants:
  scInc SCINC instruction
  scNoInc SCNOINC instruction
  // TIB instruction 
  scMove SCMOVE instruction
  scLoop SCLOOP instruction
  scNOp SCNOP instruction
  scStop SCSTOP instruction
  A description of the instructions is given below:
  scOpcode = scInc scParam1 = buffer scParam2 = count
  The SCINC instruction moves count bytes to or from buffer, incrementing
  buffer by count when done.
  scOpcode = scNoInc scParam1 = buffer scParam2 = count
  The SCNOINC instruction moves count data bytes to or from buffer, leaving
  buffer unmodified.
  scOpcode = scAdd scParam1 = addr scParam2 = value
  The SCADD instruction adds the given value to the address in addr. (The
  addition is performed as an MC68000 operation.)
  scOpcode = scMove scParam1 = addr1 scParam2 = addr2
  The SCMOVE instruction moves the value pointed to by addr1 to the location
  pointed to by addr2. (The move is an MC68000 long operation)
  scOpcode = scLoop param1 = relAddr param2 = count
  The SCLOOP instruction decrements count by 1. If the result is greater than
  0, pseudo-program execution resumes at the current address+relAddr. If the
  result is 0, pseudo-program execution resumes at the next instruction.
  RelAddr should be a signed multiple of the instruction size (10 bytes). For
  example, to loop to the immediately preceding instruction, the relAddr field
  would contain -10. To loop forward by three instructions, it would contain 30.
  scOpcode = scNOp scParam1 = NIL scParam2 = NIL
  The SCNOP instruction does nothing.
  </pre>
   * \copyright THINK Reference © 1991-1992 Symantec Corporation
  */
  struct SCSIInstr
  {
    unsigned short scOpcode; /**<}  operation code*/
    unsigned long scParam;   /**<  first parameter*/
    unsigned long scParam;   /**<  second parameter*/
  } SCSIInstr;               /**< */

  typedef struct SCSIInstr SCSIInstr;
  // SCSI Phases (used by SIMs to support the Original SCSI Manager   enum
  {
    kDataOutPhase = 0, // Encoded MSG, C/D, I/O bits     kDataInPhase = 1,
    kCommandPhase = 2,
    kStatusPhase = 3,
    kPhaseIllegal0 = 4,
    kPhaseIllegal1 = 5,
    kMessageOutPhase = 6,
    kMessageInPhase = 7,
    kBusFreePhase = 8, // Additional Phases     kArbitratePhase = 9,
    kSelectPhase = 10,
    kMessageInPhaseNACK = 11 // Message In Phase with ACK hanging on the bus   };
// SCSI Phases (used by SIMs to support the Original SCSI Manager 
#if CALL_NOT_IN_CARBON

  /**// Encoded MSG, C/D, I/O bits 
  \brief Reset the SCSI bus

  <pre>SCSIReset resets the SCSI bus.
</pre>
* \returns <pre>an error code indicating success or failure of the function. It will be
one of:
noErr(0) No error
scCommErr (2) Breakdown// Additional Phases 
</pre>
* \note <pre> The error codes returned by SCSI Manager routines typically indicate
only that a given operation h// Message In Phase with ACK hanging on the bus 
failure, another SCSI command needs to be sent asking the device what went
wrong.
</pre>
* \copyright THINK Reference © 1991-1992 Symantec Corporation

*    \non_carbon_cfm   in InterfaceLib 7.1 and later
*    \carbon_lib        not available
*    \mac_os_x         not available
*/
  OSErr
  SCSIReset(void) TWOWORDINLINE(0x4267, 0xA815);

  /**
  \brief Arbitrate for use of the SCSI bus

  <pre>SCSIGet arbitrates for use of the SCSI bus.
</pre>
* \returns <pre>an error code indicating success or failure of the function. It will be
one of:
noErr(0) No error
scCommErr (2) Breakdown in SCSI protocols
</pre>
* \note <pre> The error codes returned by SCSI Manager routines typically indicate
only that a given operation has failed. To determine the actual cause of the
failure, another SCSI command needs to be sent asking the device what went
wrong.
</pre>
* \copyright THINK Reference © 1991-1992 Symantec Corporation

*    \non_carbon_cfm   in InterfaceLib 7.1 and later
*    \carbon_lib        not available
*    \mac_os_x         not available
*/
  OSErr
  SCSIGet(void) THREEWORDINLINE(0x3F3C, 0x0001, 0xA815);

  /**
  \brief Select a SCSI device with a specific ID

  <pre>SCSISelect selects the device whose ID is targetID.
</pre>
* \returns <pre>an error code indicating success or failure of the function. It will be
one of:
noErr(0) No error
scCommErr (2) Breakdown in SCSI protocols
</pre>
* \note <pre> The error codes returned by SCSI Manager routines typically indicate
only that a given operation has failed. To determine the actual cause of the
failure, another SCSI command needs to be sent asking the device what went
wrong.
</pre>
* \copyright THINK Reference © 1991-1992 Symantec Corporation

*    \non_carbon_cfm   in InterfaceLib 7.1 and later
*    \carbon_lib        not available
*    \mac_os_x         not available
*/
  OSErr
  SCSISelect(short targetID) THREEWORDINLINE(0x3F3C, 0x0002, 0xA815);

  /**
  \brief Send a command to the selected target device

  <pre>SCSICmd sends the command pointed to by buffer to the selected target
device. The size of the command in bytes is specified in count.
bufferis a pointer to a command descriptor block; the SCSI command
structure is outlined in ANSC document X3T0.2/82-2.
countis the size of the command descriptor block pointer to by buffer.
</pre>
* \returns <pre>an error code indicating success or failure of the function. It will be
one of:
noErr(0) No error
scCommErr (2) Breakdown in SCSI protocols
scPhaseErr (5) Phase error
</pre>
* \note <pre> The error codes returned by SCSI Manager routines typically indicate
only that a given operation has failed. To determine the actual cause of the
failure, another SCSI command needs to be sent asking the device what went
wrong.
Use SCSISelect to specify the target device.
</pre>
* \copyright THINK Reference © 1991-1992 Symantec Corporation

*    \non_carbon_cfm   in InterfaceLib 7.1 and later
*    \carbon_lib        not available
*    \mac_os_x         not available
*/
  OSErr
  SCSICmd(Ptr buffer, short count) THREEWORDINLINE(0x3F3C, 0x0003, 0xA815);

  /**
  \brief Transfer data from the target to the initiator

  <pre>SCSIRead transfers data from the target to the initiator, as specified by the
transfer instructions block pointed to by tibPtr.
</pre>
* \returns <pre>an error code indicating success or failure of the function. It will be
one of:
noErr(0)No error
scBadParmsErr (4)Unrecognized instruction in transfer instruction block
scCommErr (2)Breakdown in SCSI protocols
scCompareErr (6)Data comparison error (with scComp command in
tranfer instruction block)
scPhaseErr (5)Phase error
</pre>
* \note <pre> The error codes returned by SCSI Manager routines typically indicate
only that a given operation has failed. To determine the actual cause of the
failure, another SCSI command needs to be sent asking the device what went
wrong.
A transfer instructions block tells the SCSI Manager what to do
with the data bytes transferred during the data phase. A transfer instruction
block contains a pseudo-program consisting of a variable number of
instructions; it's similar to a subroutine except that the instructions are
provided and interpreted by the SCSI Manager itself. The instructions are
of a fixed size and are of type SCSIInstr . See SCSIInstr for more
information on the the instructions that are available.
Use SCSISelect to specify the target device.
</pre>
* \copyright THINK Reference © 1991-1992 Symantec Corporation

*    \non_carbon_cfm   in InterfaceLib 7.1 and later
*    \carbon_lib        not available
*    \mac_os_x         not available
*/
  OSErr
  SCSIRead(Ptr tibPtr) THREEWORDINLINE(0x3F3C, 0x0005, 0xA815);

  /**
  \brief Transfer data without polling and waiting for /REQ line

  <pre>SCSIRBlind transfers data from the target to the initiator, as specified by
the transfer instructions block pointed to by tibPtr. It is functionally
equivalent to SCSIRead , but it does not poll and wait for the /REQ line on each
data byte. Rather the /REQ line is polled only for the first byte transferred by
each scInc, scNoInc or scComp instruction.
Given the following instruction block:
scOpcode scParam1 scParam2
scInc 0x67B50 512
scLoop -10 6
scStop
SCSIRBlind polls and wait only for the first byte of each 512-byte block
transferred.
</pre>
* \returns <pre>an error code indicating success or failure of the function. It will be
one of:
noErr(0)No error
scBadParmsErr (4)Unrecognized instruction in transfer instruction block
scCommErr (2)Breakdown in SCSI protocols
scCompareErr (6)Data comparison error
scPhaseErr (5)Phase error
</pre>
* \note <pre> The error codes returned by SCSI Manager routines typically indicate
only that a given operation has failed. To determine the actual cause of the
failure, another SCSI command needs to be sent asking the device what went
wrong.
A transfer instructions block tells the SCSI Manager what to do
with the data bytes transferred during the data phase. A transfer instruction
block contains a pseudo-program consisting of a variable number of
instructions; it's similar to a subroutine except that the instructions are
provided and interpreted by the SCSI Manager itself. The instructions are
of a fixed size and are of type SCSIInstr . See SCSIInstr for more
information on the the instructions that are available.
Use SCSISelect to specify the target device.
</pre>
* \copyright THINK Reference © 1991-1992 Symantec Corporation

*    \non_carbon_cfm   in InterfaceLib 7.1 and later
*    \carbon_lib        not available
*    \mac_os_x         not available
*/
  OSErr
  SCSIRBlind(Ptr tibPtr) THREEWORDINLINE(0x3F3C, 0x0008, 0xA815);

  /**
  \brief Transfer data from the initiator to the target

  <pre>SCSIWrite transfers data from the initiator to the target, as specified by
the transfer instructions block pointed to by tibPtr.
</pre>
* \returns <pre>an error code indicating success or failure of the function. It will be
one of:
noErr(0)No error
scBadParmsErr (4)Unrecognized instruction in transfer instruction block
scCommErr (2)Breakdown in SCSI protocols
scPhaseErr (5)Phase error
</pre>
* \note <pre> The error codes returned by SCSI Manager routines typically indicate
only that a given operation has failed. To determine the actual cause of the
failure, another SCSI command needs to be sent asking the device what went
wrong.
A transfer instructions block tells the SCSI Manager what to do
with the data bytes transferred during the data phase. A transfer instruction
block contains a pseudo-program consisting of a variable number of
instructions; it's similar to a subroutine except that the instructions are
provided and interpreted by the SCSI Manager itself. The instructions are
of a fixed size and are of type SCSIInstr . See SCSIInstr for more
information on the the instructions that are available.
Use SCSISelect to specify the target device.
</pre>
* \copyright THINK Reference © 1991-1992 Symantec Corporation

*    \non_carbon_cfm   in InterfaceLib 7.1 and later
*    \carbon_lib        not available
*    \mac_os_x         not available
*/
  OSErr
  SCSIWrite(Ptr tibPtr) THREEWORDINLINE(0x3F3C, 0x0006, 0xA815);

  /**
  \brief Transfer data without polling and waiting for /REQ line

  <pre>SCSIWBlind transfers data from the initiator to the target, as specified by
the transfer instructions block pointed to by tibPtr. SCSIWBlind is
functionally identical to SCSIWrite , but does not poll and wait for the /REQ
line on each data byte. As with SCSIRBlind , SCSIWBlind polls the /REQ
line only for the first byte transferred by each scInc, scNoInc, or scComp
instruction.
</pre>
* \returns <pre>an error code indicating success or failure of the function. It will be
one of:
noErr(0)No error
scBadParmsErr (4)Unrecognized instruction in transfer instruction block
scCommErr (2)Breakdown in SCSI protocols
scPhaseErr (5)Phase error
</pre>
* \note <pre> The error codes returned by SCSI Manager routines typically indicate
only that a given operation has failed. To determine the actual cause of the
failure, another SCSI command needs to be sent asking the device what went
wrong.
A transfer instructions block tells the SCSI Manager what to do
with the data bytes transferred during the data phase. A transfer instruction
block contains a pseudo-program consisting of a variable number of
instructions; it's similar to a subroutine except that the instructions are
provided and interpreted by the SCSI Manager itself. The instructions are
of a fixed size and are of type SCSIInstr . See SCSIInstr for more
information on the the instructions that are available.
Use SCSISelect to specify the target device.
</pre>
* \copyright THINK Reference © 1991-1992 Symantec Corporation

*    \non_carbon_cfm   in InterfaceLib 7.1 and later
*    \carbon_lib        not available
*    \mac_os_x         not available
*/
  OSErr
  SCSIWBlind(Ptr tibPtr) THREEWORDINLINE(0x3F3C, 0x0009, 0xA815);

  /**
  \brief Give current command specific number of ticks to complete

  <pre>SCSIComplete gives the current command wait number of ticks to complete;
the two completion bytes are returned in stat and message.
</pre>
* \returns <pre>an error code indicating success or failure of the function. It will be
one of:
noErr(0)No error
scCommErr (2)Breakdown in SCSI protocols
scPhaseErr (5)Phase error
</pre>
* \note <pre> The error codes returned by SCSI Manager routines typically indicate
only that a given operation has failed. To determine the actual cause of the
failure, another SCSI command needs to be sent asking the device what went
wrong.
</pre>
* \copyright THINK Reference © 1991-1992 Symantec Corporation

*    \non_carbon_cfm   in InterfaceLib 7.1 and later
*    \carbon_lib        not available
*    \mac_os_x         not available
*/
  OSErr
  SCSIComplete(short *stat, short *message, unsigned long wait)
      THREEWORDINLINE(0x3F3C, 0x0004, 0xA815);

  /**
  \brief Get bit map of SCSI control and status bits

  <pre>SCSIStat returns a bit map of SCSI control and status bits; these bits are
given below. See the NCR 5380 SCSI chip documentation for a description of
these signals (Bits 0-9 are complements of the SCSI bus standard signals.)
Bit Signal BitSignal
15END DMA 7RST
14DMA REQ 6BSY
13PTY ERR 5REQ
12INT REQ 4MSG
11PHS MAT 3C/D
10BSY ERR 2I/O
9ATN 1SEL
8ACK 0DBP
</pre>
* \returns <pre>an error code indicating success or failure of the function. It will be
one of:
noErr(0)No error
scCommErr (2)Breakdown in SCSI protocols
scPhaseErr (5)Phase error
</pre>
* \note <pre> The error codes returned by SCSI Manager routines typically indicate
only that a given operation has failed. To determine the actual cause of the
failure, another SCSI command needs to be sent asking the device what went
wrong.
</pre>
* \copyright THINK Reference © 1991-1992 Symantec Corporation

*    \non_carbon_cfm   in InterfaceLib 7.1 and later
*    \carbon_lib        not available
*    \mac_os_x         not available
*/
  short
  SCSIStat(void) THREEWORDINLINE(0x3F3C, 0x000A, 0xA815);

  /**
  \brief Select SCSI device and signal intention to send a message

  <pre>SCSISelAtn is the same as SCSISelect except that it also asserts the bus's
Attention line to indicate that there is a message pending for that drive.
targetID identifies the selected SCSI device.
</pre>
* \returns <pre>an error code indicating success or failure of the function. It will be
one of:
noErr(0) No error
scArbNBErr (3) Arbitration failure during SCSIGet; bus busy
scMgrBusyErr (7) SCSI Manager already occupied when SCSIGet was called
scSequenceErr (8) Operation out of sequence
scBusTOErr (9) Bus timeout before data ready on blind read or write
scComplPhaseErr (10) Bus not in Status phase; SCSIComplete call failed
</pre>
* \copyright THINK Reference © 1991-1992 Symantec Corporation

*    \non_carbon_cfm   in InterfaceLib 7.1 and later
*    \carbon_lib        not available
*    \mac_os_x         not available
*/
  OSErr
  SCSISelAtn(short targetID) THREEWORDINLINE(0x3F3C, 0x000B, 0xA815);

  /**
  \brief Get a message from the SCSI device

  <pre>SCSIMsgIn gets a message from the external drive.
*message is in the low-order byte of the message parameter.
</pre>
* \returns <pre>an error code indicating success or failure of the function. It will be
one of:
noErr(0) No error
scArbNBErr (3) Arbitration failure during SCSIGet; bus busy
scMgrBusyErr (7) SCSI Manager already occupied when SCSIGet was called
scSequenceErr (8) Operation out of sequence
scBusTOErr (9) Bus timeout before data ready on blind read or write
scComplPhaseErr (10) Bus not in Status phase; SCSIComplete call failed
</pre>
* \note <pre> Message values are listed in SCSI documentation from the American
National Standards Institute. This routine leaves the Attention bus line
undisturbed if it is already asserted.
</pre>
* \copyright THINK Reference © 1991-1992 Symantec Corporation

*    \non_carbon_cfm   in InterfaceLib 7.1 and later
*    \carbon_lib        not available
*    \mac_os_x         not available
*/
  OSErr
  SCSIMsgIn(short *message) THREEWORDINLINE(0x3F3C, 0x000C, 0xA815);

  /**
  \brief Send a message to the SCSI device

  <pre>SCSIMsgOut sends a message to the external drive.
*message is an ANSI-defined value in the low-order byte of the message
parameter.
</pre>
* \returns <pre>an error code indicating success or failure of the function. It will be
one of:
noErr(0) No error
scArbNBErr (3) Arbitration failure during SCSIGet; bus busy
scMgrBusyErr (7) SCSI Manager already occupied when SCSIGet was called
scSequenceErr (8) Operation out of sequence
scBusTOErr (9) Bus timeout before data ready on blind read or write
scComplPhaseErr (10) Bus not Out Status phase; SCSIComplete call failed
</pre>
* \note <pre> Message values are listed in SCSI documentation from the American
National Standards Institute.
</pre>
* \copyright THINK Reference © 1991-1992 Symantec Corporation

*    \non_carbon_cfm   in InterfaceLib 7.1 and later
*    \carbon_lib        not available
*    \mac_os_x         not available
*/
  OSErr
  SCSIMsgOut(short message) THREEWORDINLINE(0x3F3C, 0x000D, 0xA815);

#endif // CALL_NOT_IN_CARBON 
  enum
  {
    scsiVERSION = 43
  };

  /**
   * SCSI Callback Procedure Prototypes. Several of these are only callable
   * from SCSI Manager 4.3 SIM and XPT contexts.
   */
  typedef CALLBACK_API_C(void, AENCallbackProcPtr)(void);
  typedef CALLBACK_API_C(OSErr, SIMInitProcPtr)(Ptr SIMinfoPtr);
  typedef CALLBACK_API_C(void, SIMActionProcPtr)(void *scsiPB, Ptr SIMGlobals);
  typedef CALLBACK_API_C(void, SCSIProcPtr)(void);
  typedef CALLBACK_API_C(void, SCSIMakeCallbackProcPtr)(void *scsiPB);
  /* SCSIInterruptPollProcPtr is obsolete (use SCSIInterruptProcPtr) but still
   * he// CALL_NOT_IN_CARBON 
  typedef CALLBACK_API_C(long, SCSIInterruptPollProcPtr)(Ptr SIMGlobals);
  typedef CALLBACK_API_C(long, SCSIInterruptProcPtr)(Ptr SIMGlobals);
  typedef STACK_UPP_TYPE(AENCallbackProcPtr) AENCallbackUPP;
  typedef STACK_UPP_TYPE(SIMInitProcPtr) SIMInitUPP;
  typedef STACK_UPP_TYPE(SIMActionProcPtr) SIMActionUPP;
  typedef STACK_UPP_TYPE(SCSIProcPtr) SCSIUPP;
  typedef STACK_UPP_TYPE(SCSIMakeCallbackProcPtr) SCSIMakeCallbackUPP;
  typedef STACK_UPP_TYPE(SCSIInterruptPollProcPtr) SCSIInterruptPollUPP;
  typedef STACK_UPP_TYPE(SCSIInterruptProcPtr) SCSIInterruptUPP;
#if CALL_NOT_IN_CARBON
  /**
   *  NewAENCallbackUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   *    \mac_os_x         not available
   */
  AENCallbackUPP
  NewAENCallbackUPP(AENCallbackProcPtr userRoutine);
#if !OPAQUE_UPP_TYPES
  enum
  {
    uppAENCallbackProcInfo = 0x00000001
  }; // no_return_value Func() #ifdef __cplusplus
  inline AENCallbackUPP NewAENCallbackUPP(AENCallbackProcPtr userRoutine)
  {
    return (AENCallbackUPP)NewRoutineDescriptor(
        (ProcPtr)(userRoutine), uppAENCallbackProcInfo, GetCurrentArchitecture());
  }
#else
#define NewAENCallbackUPP(userRoutine)                                     \
  (AENCallbackUPP)                                                         \
      NewRoutineDescriptor((ProcPtr)(userRoutine), uppAENCallbackProcInfo, \
                           GetCurrentArchitecture())
#endif
#endif

  /**
   *  NewSIMInitUPP()
   *
   * // no_return_value Func() 
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   *    \mac_os_x         not available
   */
  SIMInitUPP
  NewSIMInitUPP(SIMInitProcPtr userRoutine);
#if !OPAQUE_UPP_TYPES
  enum
  {
    uppSIMInitProcInfo = 0x000000E1
  }; // 2_bytes Func(4_bytes) #ifdef __cplusplus
  inline SIMInitUPP NewSIMInitUPP(SIMInitProcPtr userRoutine)
  {
    return (SIMInitUPP)NewRoutineDescriptor(
        (ProcPtr)(userRoutine), uppSIMInitProcInfo, GetCurrentArchitecture());
  }
#else
#define NewSIMInitUPP(userRoutine)   \
  (SIMInitUPP) NewRoutineDescriptor( \
      (ProcPtr)(userRoutine), uppSIMInitProcInfo, GetCurrentArchitecture())
#endif
#endif

  /**
   *  NewSIMActionUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   * // 2_bytes Func(4_bytes) 
   *    \mac_os_x         not available
   */
  SIMActionUPP
  NewSIMActionUPP(SIMActionProcPtr userRoutine);
#if !OPAQUE_UPP_TYPES
  enum
  {
    uppSIMActionProcInfo = 0x000003C1
  }; // no_return_value Func(4_bytes, 4_bytes) #ifdef __cplusplus
  inline SIMActionUPP NewSIMActionUPP(SIMActionProcPtr userRoutine)
  {
    return (SIMActionUPP)NewRoutineDescriptor(
        (ProcPtr)(userRoutine), uppSIMActionProcInfo, GetCurrentArchitecture());
  }
#else
#define NewSIMActionUPP(userRoutine)   \
  (SIMActionUPP) NewRoutineDescriptor( \
      (ProcPtr)(userRoutine), uppSIMActionProcInfo, GetCurrentArchitecture())
#endif
#endif

  /**
   *  NewSCSIUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   * // no_return_value Func(4_bytes, 4_bytes) 
   */
  SCSIUPP
  NewSCSIUPP(SCSIProcPtr userRoutine);
#if !OPAQUE_UPP_TYPES
  enum
  {
    uppSCSIProcInfo = 0x00000001
  }; // no_return_value Func() #ifdef __cplusplus
  inline SCSIUPP NewSCSIUPP(SCSIProcPtr userRoutine)
  {
    return (SCSIUPP)NewRoutineDescriptor((ProcPtr)(userRoutine), uppSCSIProcInfo,
                                         GetCurrentArchitecture());
  }
#else
#define NewSCSIUPP(userRoutine)                                           \
  (SCSIUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSCSIProcInfo, \
                                 GetCurrentArchitecture())
#endif
#endif

  /**
   *  NewSCSIMakeCallbackUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   *    \mac_os_x         not available
   */// no_return_value Func() 
  SCSIMakeCallbackUPP
  NewSCSIMakeCallbackUPP(SCSIMakeCallbackProcPtr userRoutine);
#if !OPAQUE_UPP_TYPES
  enum
  {
    uppSCSIMakeCallbackProcInfo = 0x000000C1
  }; // no_return_value Func(4_bytes) #ifdef __cplusplus
  inline SCSIMakeCallbackUPP
  NewSCSIMakeCallbackUPP(SCSIMakeCallbackProcPtr userRoutine)
  {
    return (SCSIMakeCallbackUPP)NewRoutineDescriptor((ProcPtr)(userRoutine),
                                                     uppSCSIMakeCallbackProcInfo,
                                                     GetCurrentArchitecture());
  }
#else
#define NewSCSIMakeCallbackUPP(userRoutine)                               \
  (SCSIMakeCallbackUPP) NewRoutineDescriptor((ProcPtr)(userRoutine),      \
                                             uppSCSIMakeCallbackProcInfo, \
                                             GetCurrentArchitecture())
#endif
#endif

  /**
   *  NewSCSIInterruptPollUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   * // no_return_value Func(4_bytes) 
   *    \mac_os_x         not available
   */
  SCSIInterruptPollUPP
  NewSCSIInterruptPollUPP(SCSIInterruptPollProcPtr userRoutine);
#if !OPAQUE_UPP_TYPES
  enum
  {
    uppSCSIInterruptPollProcInfo = 0x000000F1
  }; // 4_bytes Func(4_bytes) #ifdef __cplusplus
  inline SCSIInterruptPollUPP
  NewSCSIInterruptPollUPP(SCSIInterruptPollProcPtr userRoutine)
  {
    return (SCSIInterruptPollUPP)NewRoutineDescriptor(
        (ProcPtr)(userRoutine), uppSCSIInterruptPollProcInfo,
        GetCurrentArchitecture());
  }
#else
#define NewSCSIInterruptPollUPP(userRoutine)                                \
  (SCSIInterruptPollUPP) NewRoutineDescriptor((ProcPtr)(userRoutine),       \
                                              uppSCSIInterruptPollProcInfo, \
                                              GetCurrentArchitecture())
#endif
#endif

  /**
   *  NewSCSIInterruptUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   * // 4_bytes Func(4_bytes) 
   */
  SCSIInterruptUPP
  NewSCSIInterruptUPP(SCSIInterruptProcPtr userRoutine);
#if !OPAQUE_UPP_TYPES
  enum
  {
    uppSCSIInterruptProcInfo = 0x000000F1
  }; // 4_bytes Func(4_bytes) #ifdef __cplusplus
  inline SCSIInterruptUPP NewSCSIInterruptUPP(SCSIInterruptProcPtr userRoutine)
  {
    return (SCSIInterruptUPP)NewRoutineDescriptor((ProcPtr)(userRoutine),
                                                  uppSCSIInterruptProcInfo,
                                                  GetCurrentArchitecture());
  }
#else
#define NewSCSIInterruptUPP(userRoutine)                                     \
  (SCSIInterruptUPP)                                                         \
      NewRoutineDescriptor((ProcPtr)(userRoutine), uppSCSIInterruptProcInfo, \
                           GetCurrentArchitecture())
#endif
#endif

  /**
   *  DisposeAENCallbackUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   *    \mac_os_x         not available
   */
  voi// 4_bytes Func(4_bytes) 
  DisposeAENCallbackUPP(AENCallbackUPP userUPP);
#if !OPAQUE_UPP_TYPES
#ifdef __cplusplus
  inline void DisposeAENCallbackUPP(AENCallbackUPP userUPP)
  {
    DisposeRoutineDescriptor((UniversalProcPtr)userUPP);
  }
#else
#define DisposeAENCallbackUPP(userUPP) DisposeRoutineDescriptor(userUPP)
#endif
#endif

  /**
   *  DisposeSIMInitUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   *    \mac_os_x         not available
   */
  void
  DisposeSIMInitUPP(SIMInitUPP userUPP);
#if !OPAQUE_UPP_TYPES
#ifdef __cplusplus
  inline void DisposeSIMInitUPP(SIMInitUPP userUPP)
  {
    DisposeRoutineDescriptor((UniversalProcPtr)userUPP);
  }
#else
#define DisposeSIMInitUPP(userUPP) DisposeRoutineDescriptor(userUPP)
#endif
#endif

  /**
   *  DisposeSIMActionUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   *    \mac_os_x         not available
   */
  void
  DisposeSIMActionUPP(SIMActionUPP userUPP);
#if !OPAQUE_UPP_TYPES
#ifdef __cplusplus
  inline void DisposeSIMActionUPP(SIMActionUPP userUPP)
  {
    DisposeRoutineDescriptor((UniversalProcPtr)userUPP);
  }
#else
#define DisposeSIMActionUPP(userUPP) DisposeRoutineDescriptor(userUPP)
#endif
#endif

  /**
   *  DisposeSCSIUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   *    \mac_os_x         not available
   */
  void
  DisposeSCSIUPP(SCSIUPP userUPP);
#if !OPAQUE_UPP_TYPES
#ifdef __cplusplus
  inline void DisposeSCSIUPP(SCSIUPP userUPP)
  {
    DisposeRoutineDescriptor((UniversalProcPtr)userUPP);
  }
#else
#define DisposeSCSIUPP(userUPP) DisposeRoutineDescriptor(userUPP)
#endif
#endif

  /**
   *  DisposeSCSIMakeCallbackUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   *    \mac_os_x         not available
   */
  void
  DisposeSCSIMakeCallbackUPP(SCSIMakeCallbackUPP userUPP);
#if !OPAQUE_UPP_TYPES
#ifdef __cplusplus
  inline void DisposeSCSIMakeCallbackUPP(SCSIMakeCallbackUPP userUPP)
  {
    DisposeRoutineDescriptor((UniversalProcPtr)userUPP);
  }
#else
#define DisposeSCSIMakeCallbackUPP(userUPP) DisposeRoutineDescriptor(userUPP)
#endif
#endif

  /**
   *  DisposeSCSIInterruptPollUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   *    \mac_os_x         not available
   */
  void
  DisposeSCSIInterruptPollUPP(SCSIInterruptPollUPP userUPP);
#if !OPAQUE_UPP_TYPES
#ifdef __cplusplus
  inline void DisposeSCSIInterruptPollUPP(SCSIInterruptPollUPP userUPP)
  {
    DisposeRoutineDescriptor((UniversalProcPtr)userUPP);
  }
#else
#define DisposeSCSIInterruptPollUPP(userUPP) DisposeRoutineDescriptor(userUPP)
#endif
#endif

  /**
   *  DisposeSCSIInterruptUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   *    \mac_os_x         not available
   */
  void
  DisposeSCSIInterruptUPP(SCSIInterruptUPP userUPP);
#if !OPAQUE_UPP_TYPES
#ifdef __cplusplus
  inline void DisposeSCSIInterruptUPP(SCSIInterruptUPP userUPP)
  {
    DisposeRoutineDescriptor((UniversalProcPtr)userUPP);
  }
#else
#define DisposeSCSIInterruptUPP(userUPP) DisposeRoutineDescriptor(userUPP)
#endif
#endif

  /**
   *  InvokeAENCallbackUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   *    \mac_os_x         not available
   */
  void
  InvokeAENCallbackUPP(AENCallbackUPP userUPP);
#if !OPAQUE_UPP_TYPES
#ifdef __cplusplus
  inline void InvokeAENCallbackUPP(AENCallbackUPP userUPP)
  {
    CALL_ZERO_PARAMETER_UPP(userUPP, uppAENCallbackProcInfo);
  }
#else
#define InvokeAENCallbackUPP(userUPP) \
  CALL_ZERO_PARAMETER_UPP((userUPP), uppAENCallbackProcInfo)
#endif
#endif

  /**
   *  InvokeSIMInitUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   *    \mac_os_x         not available
   */
  OSErr
  InvokeSIMInitUPP(Ptr SIMinfoPtr, SIMInitUPP userUPP);
#if !OPAQUE_UPP_TYPES
#ifdef __cplusplus
  inline OSErr InvokeSIMInitUPP(Ptr SIMinfoPtr, SIMInitUPP userUPP)
  {
    return (OSErr)CALL_ONE_PARAMETER_UPP(userUPP, uppSIMInitProcInfo, SIMinfoPtr);
  }
#else
#define InvokeSIMInitUPP(SIMinfoPtr, userUPP) \
  (OSErr) CALL_ONE_PARAMETER_UPP((userUPP), uppSIMInitProcInfo, (SIMinfoPtr))
#endif
#endif

  /**
   *  InvokeSIMActionUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   *    \mac_os_x         not available
   */
  void
  InvokeSIMActionUPP(void *scsiPB, Ptr SIMGlobals, SIMActionUPP userUPP);
#if !OPAQUE_UPP_TYPES
#ifdef __cplusplus
  inline void InvokeSIMActionUPP(void *scsiPB, Ptr SIMGlobals,
                                 SIMActionUPP userUPP)
  {
    CALL_TWO_PARAMETER_UPP(userUPP, uppSIMActionProcInfo, scsiPB, SIMGlobals);
  }
#else
#define InvokeSIMActionUPP(scsiPB, SIMGlobals, userUPP)             \
  CALL_TWO_PARAMETER_UPP((userUPP), uppSIMActionProcInfo, (scsiPB), \
                         (SIMGlobals))
#endif
#endif

  /**
   *  InvokeSCSIUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   *    \mac_os_x         not available
   */
  void
  InvokeSCSIUPP(SCSIUPP userUPP);
#if !OPAQUE_UPP_TYPES
#ifdef __cplusplus
  inline void InvokeSCSIUPP(SCSIUPP userUPP)
  {
    CALL_ZERO_PARAMETER_UPP(userUPP, uppSCSIProcInfo);
  }
#else
#define InvokeSCSIUPP(userUPP) \
  CALL_ZERO_PARAMETER_UPP((userUPP), uppSCSIProcInfo)
#endif
#endif

  /**
   *  InvokeSCSIMakeCallbackUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   *    \mac_os_x         not available
   */
  void
  InvokeSCSIMakeCallbackUPP(void *scsiPB, SCSIMakeCallbackUPP userUPP);
#if !OPAQUE_UPP_TYPES
#ifdef __cplusplus
  inline void InvokeSCSIMakeCallbackUPP(void *scsiPB,
                                        SCSIMakeCallbackUPP userUPP)
  {
    CALL_ONE_PARAMETER_UPP(userUPP, uppSCSIMakeCallbackProcInfo, scsiPB);
  }
#else
#define InvokeSCSIMakeCallbackUPP(scsiPB, userUPP) \
  CALL_ONE_PARAMETER_UPP((userUPP), uppSCSIMakeCallbackProcInfo, (scsiPB))
#endif
#endif

  /**
   *  InvokeSCSIInterruptPollUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   *    \mac_os_x         not available
   */
  long
  InvokeSCSIInterruptPollUPP(Ptr SIMGlobals, SCSIInterruptPollUPP userUPP);
#if !OPAQUE_UPP_TYPES
#ifdef __cplusplus
  inline long InvokeSCSIInterruptPollUPP(Ptr SIMGlobals,
                                         SCSIInterruptPollUPP userUPP)
  {
    return (long)CALL_ONE_PARAMETER_UPP(userUPP, uppSCSIInterruptPollProcInfo,
                                        SIMGlobals);
  }
#else
#define InvokeSCSIInterruptPollUPP(SIMGlobals, userUPP)                 \
  (long)CALL_ONE_PARAMETER_UPP((userUPP), uppSCSIInterruptPollProcInfo, \
                               (SIMGlobals))
#endif
#endif

  /**
   *  InvokeSCSIInterruptUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        not available
   *    \mac_os_x         not available
   */
  long
  InvokeSCSIInterruptUPP(Ptr SIMGlobals, SCSIInterruptUPP userUPP);
#if !OPAQUE_UPP_TYPES
#ifdef __cplusplus
  inline long InvokeSCSIInterruptUPP(Ptr SIMGlobals, SCSIInterruptUPP userUPP)
  {
    return (long)CALL_ONE_PARAMETER_UPP(userUPP, uppSCSIInterruptProcInfo,
                                        SIMGlobals);
  }
#else
#define InvokeSCSIInterruptUPP(SIMGlobals, userUPP)                 \
  (long)CALL_ONE_PARAMETER_UPP((userUPP), uppSCSIInterruptProcInfo, \
                               (SIMGlobals))
#endif
#endif

#endif // CALL_NOT_IN_CARBON 
#if CALL_NOT_IN_CARBON || OLDROUTINENAMES
// support for pre-Carbon UPP routines: New...Proc and Call...Proc #define NewAENCallbackProc(userRoutine) NewAENCallbackUPP(userRoutine)
#define NewSIMInitProc(userRoutine) NewSIMInitUPP(userRoutine)
#define NewSIMActionProc(userRoutine) NewSIMActionUPP(userRoutine)
#define NewSCSIProc(userRoutine) NewSCSIUPP(userRoutine)
#define NewSCSIMakeCallbackProc(userRoutine) NewSCSIMakeCallbackUPP(userRoutine)
#define NewSCSIInterruptPollProc(userRoutine) \
  NewSCSIInterruptPollUPP(userRoutine)
#define NewSCSIInterruptProc(userRoutine) NewSCSIInterruptUPP(userRoutine)
#define CallAENCallbackProc(userRoutine) InvokeAENCallbackUPP(userRoutine)
#define CallSIMInitProc(userRoutine, SIMinfoPtr) \
  InvokeSIMInitUPP(SIMinfoPtr, userRoutine)
#define CallSIMActionProc(userRoutine, scsiPB, SIMGlobals) \
  InvokeSIMActionUPP(scsiPB, SIMGlobals, userRoutine)
#define CallSCSIProc(userRoutine) InvokeSCSIUPP(userRoutine)
#define CallSCSIMakeCallbackProc(userRoutine, scsiPB) \
  InvokeSCSIMakeCallbackUPP(scsiPB, userRoutine)
#define CallSCSIInterruptPollProc(userRoutine, SIMGlobals) \
  InvokeSCSIInterruptPollUPP(SIMGlobals, userRoutine)
#define CallSCSIInterruptProc(userRoutine, SIMGlobals) \
  InvokeSCSIInterruptUPP(SIMGlobals, userRoutine)
#endif // CALL_NOT_IN_CARBON 
  /**
   * SC// CALL_NOT_IN_CARBON 
   */
  typedef CALLBACK_API(void, SCSICallbackProcPtr)(void *scsiPB);
// support for pre-Carbon UPP routines: New...Proc and Call...Proc 
  /**
   *  NewSCSICallbackUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        in CarbonLib 1.3 and later
   *    \mac_os_x         in version 10.0 and later
   */
  SCSICallbackUPP
  NewSCSICallbackUPP(SCSICallbackProcPtr userRoutine);
#if !OPAQUE_UPP_TYPES
  enum
  {
    uppSCSICallbackProcInfo = 0x000000C0
  }; // pascal no_return_value Func(4_bytes) #ifdef __cplusplus
  inline SCSICallbackUPP NewSCSICallbackUPP(SCSICallbackProcPtr userRoutine)
  {
    return (SCSICallbackUPP)NewRoutineDescriptor((ProcPtr)(userRoutine),
                                                 uppSCSICallbackProcInfo,
                                                 GetCurrentArchitecture());
  }// CALL_NOT_IN_CARBON 
#else
#define NewSCSICallbackUPP(userRoutine)                                     \
  (SCSICallbackUPP)                                                         \
      NewRoutineDescriptor((ProcPtr)(userRoutine), uppSCSICallbackProcInfo, \
                           GetCurrentArchitecture())
#endif
#endif

  /**
   *  DisposeSCSICallbackUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        in CarbonLib 1.3 and later
   *    \mac_os_x         in version 10.0 and later
   */
  void
  DisposeSCSICallbackUPP(SCSICallbackUPP userUPP);
#if !OPAQUE_UPP_TYPES
#ifdef __cplusplus
  inl// pascal no_return_value Func(4_bytes) 
  {
    DisposeRoutineDescriptor((UniversalProcPtr)userUPP);
  }
#else
#define DisposeSCSICallbackUPP(userUPP) DisposeRoutineDescriptor(userUPP)
#endif
#endif

  /**
   *  InvokeSCSICallbackUPP()
   *
   *  Availability:
   *    \non_carbon_cfm   available as macro/inline
   *    \carbon_lib        in CarbonLib 1.3 and later
   *    \mac_os_x         in version 10.0 and later
   */
  void
  InvokeSCSICallbackUPP(void *scsiPB, SCSICallbackUPP userUPP);
#if !OPAQUE_UPP_TYPES
#ifdef __cplusplus
  inline void InvokeSCSICallbackUPP(void *scsiPB, SCSICallbackUPP userUPP)
  {
    CALL_ONE_PARAMETER_UPP(userUPP, uppSCSICallbackProcInfo, scsiPB);
  }
#else
#define InvokeSCSICallbackUPP(scsiPB, userUPP) \
  CALL_ONE_PARAMETER_UPP((userUPP), uppSCSICallbackProcInfo, (scsiPB))
#endif
#endif

#if CALL_NOT_IN_CARBON || OLDROUTINENAMES
// support for pre-Carbon UPP routines: New...Proc and Call...Proc #define NewSCSICallbackProc(userRoutine) NewSCSICallbackUPP(userRoutine)
#define CallSCSICallbackProc(userRoutine, scsiPB) \
  InvokeSCSICallbackUPP(scsiPB, userRoutine)
#endif // CALL_NOT_IN_CARBON 
  /**
     SCSI Manager 4.3 function codes
   */
  enum
  {
    SCSINop = 0x00,          // Execute nothing                              SCSIExecIO = 0x01,       // Execute the specified IO                      SCSIBusInquiry = 0x03,   // Get parameters for entire path of HBAs               SCSIReleaseQ = 0x04,     // Release the frozen SIM queue for particular LUN       SCSIAbortCommand = 0x10, // Abort the selected Control Block                 SCSIResetBus = 0x11,     // Reset the SCSI bus                             SCSIResetDevice = 0x12,  // Reset the SCSI device                          SCSITerminateIO = 0x13   // Terminate any pending IO                      };

  // Not available in Carbon on X   enum
  {
    SCSIGetVirtualIDInfo = 0x80, // Find out which bus old ID is on     SCSILoadDriver = 0x82,       // Load a driver for a device ident                 SCSIOldCall = 0x84,          // XPT->SIM private call for old-API                SCSICreateRefNumXref = 0x85, // Register a DeviceIdent to drvr RefNum xref     SCSILookupRefNumXref = 0x86, // Get DeviceIdent to drvr RefNum xref     SCSIRemoveRefNumXref = 0x87, // Remove a DeviceIdent to drvr RefNum xref     SCSIRegisterWithNewXPT =
        0x88 // XPT has changed - SIM needs to re-register itself    };

  enum
  {
    vendorUnique = 0xC0 // 0xC0 thru 0xFF   };

  // Allocation length defines for some of the fields   enum
  {
    handshakeDataLength = 8, // Handshake data length     maxCDBLength = 16,       // Space for the CDB bytes/pointer     vendorIDLength = 16      // ASCII string len for Vendor ID    };

  // Define DeviceIdent structure   struct DeviceIdent
  {
    UInt8 diReserved; // reserved               UInt8 bus;        // SCSI - Bus Number       UInt8 targetID;   // SCSI - Target SCSI ID      UInt8 LUN;        // SCSI - LUN              };
  typedef struct DeviceIdent DeviceIdent;
// support for pre-Carbon UPP routines: New...Proc and Call...Proc 
  {
    kBusTypeSCSI = 0,
    kBusTypeATA = 1,
    kBu// CALL_NOT_IN_CARBON 
    kBusTypeMediaBay = 3
  };

  // If diReserved indicates that a DeviceIdent is       // really for ATA, you can cast it to DeviceIdentATA   // to get at the important fields.                     struct DeviceIdentATA
  {
    UInt8 diReserved;
    UInt8 busNum;// Execute nothing                          
    UInt8 devNum;// Execute the specified IO                  
    UInt8 diReserved2;// Get parameters for entire path of HBAs           
  };// Release the frozen SIM queue for particular LUN   
  typedef struct DeviceIdentA// Abort the selected Control Block             
  // for use with Apple Patch// Reset the SCSI bus                         
  {// Reset the SCSI device                      
    OSType patchSig;         // Terminate any pending IO                    
  typedef struct PatchDescriptor PatchDescriptor;
  // Constants for the flags field of PatchDescriptor.   enum
  // Not available in Carbon on X 
    kRequiredPatch = 0x00000001 // Patch must succeed to continue booting.   };

  struct PatchList// Find out which bus old ID is on 
  {// Load a driver for a device ident             
    UInt16 numPatchBlocks;       // XPT->SIM private call for old-API            
  typedef struct PatchList PatchL// Register a DeviceIdent to drvr RefNum xref 
  // signature of a Patch entry p// Get DeviceIdent to drvr RefNum xref 
                                 // Remove a DeviceIdent to drvr RefNum xref 

  // Command // XPT has changed - SIM needs to re-register itself  
  {
    BytePtr cdbPtr;     // pointer to the CDB, or     UInt8 cdbBytes[16]; // the actual CDB to send   };
  typedef union CDB CDB;
  typedef CDB *CDBPtr;
  // Scatter/gather list// 0xC0 thru 0xFF 
  {
    Ptr SGAddr;
  // Allocation length defines for some of the fields 
  };
  typedef struct SGRecord SGRecord;
// Handshake data length 
#define SCSIPBHdr            // Space for the CDB bytes/pointer 
  struct SCSIHdr *qLink;     // ASCII string len for Vendor ID  
  short scsiReserved1;            \
  UInt16 scsiPBLength;            \
  // Define DeviceIdent structure 
  UInt8 scsiReserved2;            \
  volatile OSErr scsiResult;      \
  DeviceIdent scsiDevi// reserved           
  SCSICallbackUPP scsi// SCSI - Bus Number   
  UInt32 scsiFlags;   // SCSI - Target SCSI ID  
  UInt8 *scsiDriverSto// SCSI - LUN            
  Ptr scsiXPTprivate;             \
  long scsiReserved3;
// Constants for the diReserved field of DeviceIdent 
  // used to distinguish whether the DeviceIdent holds 
  // information about a SCSI device (kBusTypeSCSI)    
  // or an ATA device (kBusTypeATA).  The other        
  // constants are pretty much deprecated.  Let me     
  // know if you see any.                              
  {
    SCSIHdr *qLink;                 // (internal use, must be nil on entry)       short scsiReserved1;            // ->     reserved for input              UInt16 scsiPBLength;            // -> Length of the entire PB            UInt8 scsiFunctionCode;         // -> function selector               UInt8 scsiReserved2;            // <-     reserved for output              volatile OSErr scsiResult;      // <- Returned result                   DeviceIdent scsiDevice;         // -> Device Identifier (bus+target+lun)    SCSICallbackUPP scsiCompletion; // -> Callback on completion function         UInt32 scsiFlags;               // -> assorted flags                BytePtr scsiDriverStorage;      // <> Ptr for driver private use       Ptr scsiXPTprivate;             // private field for use in XPT          long scsiReserved3;             // reserved                      };
  typedef struct SCSI_PB SCSI_PB;
  struct SCSI_IO
  {
    SCSIHdr *qLink;                 // (internal use, must be nil on entry)       short scsiReserved1;            // ->     reserved for input              UInt16 scsiPBLength;            // -> Length of the entire PB            UInt8 scsiFunctionCode;         // -> function selector               UInt8 scsiReserved2;            // <-     reserved for output              volatile OSErr scsiResult;      // <- Returned result                   DeviceIdent scsiDevice;         // -> Device Identifier (bus+target+lun)    SCSICallbackUPP scsiCompletion; // -> Callback on completion function         UInt32 scsiFlags;               // -> assorted flags                BytePtr scsiDriverStorage;      // <> Ptr for driver private use       Ptr scsiXPTprivate;             // private field for use in XPT          long scsiReserved3;             // reserved                    
    UInt16 scsiResultFlags;   // <- Flags which modify the scsiResult field         UInt16 scsiReserved3pt5;  // -> Reserved                               BytePtr scsiDataPtr;      // -> Pointer to the data buffer or the S/G list          UInt32 scsiDataLength;    // -> Data transfer length                       BytePtr scsiSensePtr;     // -> Ptr to autosense data buffer                UInt8 scsiSenseLength;    // -> size of the autosense buffer                  UInt8 scsiCDBLength;      // -> Number of bytes for the CDB                   UInt16 scsiSGListCount;   // -> num of scatter gather list entries               UInt32 scsiReserved4;     // <-     reserved for output                       UInt8 scsiSCSIstatus;     // <- Returned scsi device status                   SInt8 scsiSenseResidual;  // <- Autosense residual length                 UInt16 scsiReserved5;     // <-     reserved for output                     long scsiDataResidual;    // <- Returned Transfer residual length              CDB scsiCDB;              // -> Actual CDB or pointer to CDB                long scsiTimeout;         // -> Timeout value (Time Mgr format) (CAM timeout)     BytePtr scsiReserved5pt5; // -> Reserved                               UInt16 scsiReserved5pt6;  // -> Reserved                               UInt16 scsiIOFlags;       // -> additional I/O flags                          UInt8 scsiTagAction;      // -> What to do for tag queuing                    UInt8 scsiReserved6;      // ->     reserved for input                       UInt16 scsiReserved7;     // ->     reserved for input                       UInt16 scsiSelectTimeout; // -> Select timeout value                     UInt8 scsiDataType;       // -> Data description type (i.e. buffer, TIB, S/G)       UInt8 scsiTransferType;   // -> Transfer type (i.e. Blind vs Polled)           UInt32 scsiReserved8;     // ->     reserved for input                      UInt32 scsiReserved9;     // ->     reserved for input                      UInt16 scsiHandshake[8];  // -> handshaking points (null term'd)        UInt32 scsiReserved10;    // ->     reserved for input                      UInt32 scsiReserved11;    // ->   reserved for input                       struct SCSI_IO
        *scsiCommandLink; // -> Ptr to the next PB in linked cmd chain      
  // If diReserved indicates that a DeviceIdent is     
  // really for ATA, you can cast it to DeviceIdentATA 
  // to get at the important fields.                   
  typedef struct SCSI_IO SCSI_IO;
  typedef SCSI_IO SCSIExecIOPB;
  // Bus inquiry PB   struct SCSIBusInquiryPB
  {
    SCSIHdr *qLink;                 // (internal use, must be nil on entry)       short scsiReserved1;            // ->     reserved for input              UInt16 scsiPBLength;            // -> Length of the entire PB            UInt8 scsiFunctionCode;         // -> function selector               UInt8 scsiReserved2;            // <-     reserved for output              volatile OSErr scsiResult;      // <- Returned result                   DeviceIdent scsiDevice;         // -> Device Identifier (bus+target+lun)    SCSICallbackUPP scsiCompletion; // -> Callback on completion function         UInt32 scsiFlags;               // -> assorted flags                BytePtr scsiDriverStorage;      // <> Ptr for driver private use       Ptr scsiXPTprivate;             // private field for use in XPT          long scsiReserved3;             // reserved                    
    UInt16 scsiEngineCount;     // <- Number of engines on HBA                    UInt16 scsiMaxTransferType; // <- Number of transfer types for this HBA 
    UInt32 scsiDataTypes; // <- which data types are supported by this SIM  
    UInt16 scsiIOpbSize;    // <- Size of SCSI_IO PB for this SIM/HBA              UInt16 scsiMaxIOpbSize; // <- Size of max SCSI_IO PB for all SIM/HBAs 
  // for use with Apple Patch Driver used during booting
    UInt8 scsiVersionNumber;   // <- Version number for the SIM/HBA               UInt8 scsiHBAInquiry;      // <- Mimic of INQ byte 7 for the HBA               UInt8 scsiTargetModeFlags; // <- Flags for target mode support               UInt8 scsiScanFlags;       // <- Scan related feature flags            
    UInt32 scsiSIMPrivatesPtr;  // <- Ptr to SIM private data area                  UInt32 scsiSIMPrivatesSize; // <- Size of SIM private data area               UInt32 scsiAsyncFlags;      // <- Event cap. for Async Callback           
    UInt8 scsiHiBusID;      // // The patches signature                
    UInt32 scsiBIReserved1;    // The major version number of the      
    UInt16 scsiIOFlagsSupported// patch                                
    char scsiSIMVendor[16];    // The minor version number of the      
    char scsiXPTversion[4]; // // patch                                
    UInt8 scsiHBAslotType;   //// Reqired/Optional, etc.               
    UInt16 scsiBIReserved3;    // Block offset to the beginning of     
  typedef struct SCSIBusInquiry// the patch                            
  // Abort SIM Request PB   str// Actual size of the patch in bytes    
  {// As calculated by the SCSI drivers    
    SCSIHdr *qLink;            // CRC code                             
  typedef struct SCSIAbortComma// Total length of the descriptor       
  // Terminate I/O Process Requ// (must be >= 61 bytes)                
  {// Pascal string with a short           
    SCSIHdr *qLink;            // description of the patch             
  typedef struct SCSITerminateI// The first byte of a pascal string    
  // Reset SCSI Bus PB   struct// for the patch Vendor. Any amount     
  {// of data may follow the string.       
    SCSIHdr *qLink;                 // (internal use, must be nil on entry)       short scsiReserved1;            // ->     reserved for input              UInt16 scsiPBLength;            // -> Length of the entire PB            UInt8 scsiFunctionCode;         // -> function selector               UInt8 scsiReserved2;            // <-     reserved for output              volatile OSErr scsiResult;      // <- Returned result                   DeviceIdent scsiDevice;         // -> Device Identifier (bus+target+lun)    SCSICallbackUPP scsiCompletion; // -> Callback on completion function         UInt32 scsiFlags;               // -> assorted flags                BytePtr scsiDriverStorage;      // <> Ptr for driver private use       Ptr scsiXPTprivate;             // private field for use in XPT          long scsiReserved3;             // reserved                      };
  typedef struct SCSIResetBusPB SCSIResetBusPB;
  // Constants for the flags field of PatchDescriptor. 
  {
    SCSIHdr *qLink;                 // (internal use, must be nil on entry)       short scsiReserved1;            // ->     reserved for input              UInt16 scsiPBLength;            // -> Length of the entire PB            UInt8 scsiFunctionCode;         // -> function selector               UInt8 scsiReserved2;            // <-     reserved for output              volatile OSErr scsiResult;      // <- Returned result                   DeviceIdent scsiDevice;         // -> Device Identifier (bus+target+lun)    SCSICallbackUPP scsiCompletion; // -> Callback on completion function         UInt32 scsiFlags;               // -> assorted flags                BytePtr scsiDriverStorage;      // <> Ptr for driver private use       Ptr scsiXPTprivate;             // private field for use in XPT          long scsiReserved3;             // reserved                      };
  typedef struct SCSIResetDevice// Patch must succeed to continue booting. 
  // Release SIM Queue PB   struct SCSIReleaseQPB
  {
    SCSIHdr *qLink;                 // (internal use, must be nil on entry)       short scsiReserved1;            // ->     reserved for input              UInt16 scsiPBLength;            // -> Length of the entire PB            UInt8 scsiFunctionCode;         // -> function selector               UInt8 scsiReserved2;            // <-     reserved for output              volatile OSErr scsiResult;      // <- Returned result                   DeviceIdent scsiDevice;         // -> Device Identifier (bus+target+lun)    SCSICallbackUPP scsiCompletion; // -> Callback on completion function         UInt32 scsiFlags;               // -> assorted flags                BytePtr scsiDriverStorage;      // <> Ptr for driver private use       Ptr scsiXPTprivate;             // private field for use in XPT          long scsiReserved3;             // reserved                      };
  typedef struct SCSIReleaseQPB SCSIReleaseQPB;
  // SCSI Get Virtual ID Info PB // The number of disk blocks        
  {// to hold patch descriptions       
    SCSIHdr *qLink;              // The number of patches            
  };// An array with one patch          
  typedef struct SCSIGetVirtualID// per element                      
  // Create/Lookup/Remove RefNum for Device PB   struct SCSIDriverPB
  {
  // signature of a Patch entry point
  typedef struct SCSIDriverPB SCSIDriverPB;
  // Load Driver PB   struct SCSILoadDriverPB
  {
  // Command Descriptor Block structure 
        scsiDiskLoadFailed; // -> if true, indicates call after failure to load     SInt8 filler;
  };
  typedef struct SCSILoa// pointer to the CDB, or 
// the actual CDB to send 
  // Defines for the scsiTransferType field   enum
  {
    scsiTransferBlind = 0,
  // Scatter/gather list element (Deprecated for MacOS8) 
  };

  enum
  {
    scsiErrorBase = -7936
  };

  enum
  {
    scsiRequestInProgress = 1, // 1   = PB request is in progress                                         // Execution failed  00-2F     scsiRequestAborted =
        scsiErrorBase + 2, // -7934 = PB request aborted by the host            scsiUnableToAbort =
        scsiErrorBase + 3, // -7933 = Unable to Abort PB request              scsiNonZeroStatus =
        scsiErrorBase + 4,            // -7932 = PB request completed with an err       scsiUnused05 = scsiErrorBase + 5, // -7931 =                            scsiUnused06 = scsiErrorBase + 6, // -7930 =                            scsiUnused07 = scsiErrorBase + 7, // -7929 =                            scsiUnused08 = scsiErrorBase + 8, // -7928 =                            scsiUnableToTerminate =
        scsiErrorBase + 9,                            // -7927 = Unable to Terminate I/O PB req            scsiSelectTimeout = scsiErrorBase + 10,           // -7926 = Target selection timeout     scsiCommandTimeout = scsiErrorBase + 11,          // -7925 = Command timeout     scsiIdentifyMessageRejected = scsiErrorBase + 12, // -7924 =     scsiMessageRejectReceived =
        scsiErrorBase + 13, // -7923 = Message reject received               scsiSCSIBusReset =
        scsiErrorBase + 14, // -7922 = SCSI bus reset sent/received        scsiParityError =
        scsiErrorBase + 15, // -7921 = Uncorrectable parity error occured         scsiAutosenseFailed =
        scsiErrorBase + 16,            // -7920 = Autosense: Request sense cmd fail      scsiUnused11 = scsiErrorBase + 17, // -7919 =                            scsiDataRunError =
        scsiErrorBase + 18,                     // -7918 = Data overrun/underrun error         scsiUnexpectedBusFree = scsiErrorBase + 19, // -7917 = Unexpected BUS free     scsiSequenceFailed =
        scsiErrorBase + 20, // -7916 = Target bus phase sequence failure      scsiWrongDirection =
        scsiErrorBase + 21,            // -7915 = Data phase was in wrong direction      scsiUnused16 = scsiErrorBase + 22, // -7914 =                            scsiBDRsent =
        scsiErrorBase + 23, // -7913 = A SCSI BDR msg was sent to target      scsiTerminated =
        scsiErrorBase + 24,           // -7912 = PB request terminated by the host      scsiNoNexus = scsiErrorBase + 25, // -7911 = Nexus is not established     scsiCDBReceived =
        scsiErrorBase + 26, // -7910// (internal use, must be nil on entry)   
        scsiErrorBase + 48,        /// ->     reserved for input          
        scsiErrorBase + 50, // -7886// -> Length of the entire PB        
        scsiErrorBase + 51,         // -> function selector           
        scsiErrorBase + 53,         // <-     reserved for output          
        scsiErrorBase + 55, // -7881// <- Returned result               
        scsiErrorBase + 64, // -7872// -> Device Identifier (bus+target+lun)
        scsiErrorBase + 65,         // -> Callback on completion function     
        scsiErrorBase + 68,         // -> assorted flags            
        scsiErrorBase + 71, // -7865// <> Ptr for driver private use   
        scsiErrorBase + 72, // -7864// private field for use in XPT      
        scsiErrorBase + 73 // -7863 // reserved                    

  // New errors for SCSI Family           enum
  {
    scsiUnused74 = scsiErrorBase + 74,      // -7862 =                              scsiUnused75 = scsiErrorBase + 75,      // -7861 =                              scsiBadDataLength = scsiErrorBase + 76, // -7860 = a zero data length in PB     scsiPartialPrepared =
        scsiErrorBase + 77, // -7859// (internal use, must be nil on entry)   
        scsiErrorBase + 78,         // ->     reserved for input          
        scsiErrorBase + 82,         // -> Length of the entire PB        
        scsiErrorBase + 87 // -7849 // -> function selector           
// <-     reserved for output          
  // +++   /**// <- Returned result               
   * scsiFamilyInternalError and scs// -> Device Identifier (bus+target+lun)
   * consistency check failures. For// -> Callback on completion function     
   * lookaside queue, but does not f// -> assorted flags            
   * report this failure. SCSI Manag// <> Ptr for driver private use   
   * this is probably not the best e// private field for use in XPT      
   * reported as bugs.// reserved                    
   *
   * The following range of errors is provided for third-party (non-Apple) SCSI
   * SIM and device driver vendors. In general, they would be used for error
   * conditions that are not covered by the standardized errors. They should not
   * normally be conveyed to normal // (internal use, must be nil on entry)   
   * communication between a plug-in// ->     reserved for input          
   * example, to manage RAID hot-swa// -> Length of the entire PB        
   *// -> function selector           
   * Note: I don't know how many SCS// <-     reserved for output          
   * architecture. Don't assume that// <- Returned result               
   * reserve at least one.// -> Device Identifier (bus+target+lun)
   */// -> Callback on completion function     
  enum// -> assorted flags            
  {// <> Ptr for driver private use   
    scsiFamilyInternalError =// private field for use in XPT      
        scsiErrorBase + 87, // -7849// reserved                    
        scsiErrorBase + 88, // -7848 = Internal consistency check failed      scsiVendorSpecificErrorBase =
        scsiErrorBase + 128,  // <- Flags which modify the scsiResult field     
// -> Reserved                           
  // ---   enum// -> Pointer to the data buffer or the S/G list      
  {// -> Data transfer length                   
    scsiExecutionErrors = scsi// -> Ptr to autosense data buffer            
    scsiNotExecutedErrors = sc// -> size of the autosense buffer              
    scsiParameterErrors = scsi// -> Number of bytes for the CDB               
  };// -> num of scatter gather list entries           
// <-     reserved for output                   
  // Defines for the scsiResul// <- Returned scsi device status               
  {// <- Autosense residual length             
    scsiSIMQFrozen = 0x0001,  // <-     reserved for output                 
// <- Returned Transfer residual length          
  /* Defines for the bit numbe// -> Actual CDB or pointer to CDB            
   * SCSIExecIO function */// -> Timeout value (Time Mgr format) (CAM timeout) 
  enum// -> Reserved                           
  {// -> Reserved                           
    kbSCSIDisableAutosense = 2// -> additional I/O flags                      
// -> What to do for tag queuing                
  // Defines for the bit masks// ->     reserved for input                   
  {// ->     reserved for input                   
    scsiDirectionMask = (long)// -> Select timeout value                 
// -> Data description type (i.e. buffer, TIB, S/G)   
  // bit masks for the scsiIOF// -> Transfer type (i.e. Blind vs Polled)       
  {// ->     reserved for input                  
    scsiNoParityCheck = 0x0002// ->     reserved for input                  
        0x0100, // renegotiate// -> handshaking points (null term'd)    
        0x0200,               // ->     reserved for input                  
// ->   reserved for input                   
  // Defines for the Bus Inquiry PB fields.   // scsiHBAInquiry field bits   enum
  {// -> Ptr to the next PB in linked cmd chain      
    scsiBusMDP = 0x80,       // Supports Modify Data Pointer message                   scsiBusWide32 = 0x40,    // Supports 32 bit wide SCSI                        scsiBusWide16 = 0x20,    // Supports 16 bit wide SCSI                        scsiBusSDTR = 0x10,      // Supports Sync Data Transfer Req message                  scsiBusLinkedCDB = 0x08, // Supports linked CDBs                             scsiBusTagQ = 0x02,      // Supports tag queue message                        scsiBusSoftReset = 0x01  // Supports soft reset                             };
// ->     reserved for input to 3rd-party SIMs     
  // Defines for the scsiDataType// -> reserved for input                     
  {
    // XPT layer privates (for old-API emulation) 
  };
// <- phase upon completing old call            
  // scsiDataTypes field bits// -> selector specified in old calls            
  {// <- result of old call                     
    scsiBusDataTIB = (1 << sc// <- Returned scsi device message (for SCSIComplete)
        (1 << scsiDataBuffer)// <> various flags                       
        (1 << scsiDataIOTable//                              

  // scsiScanFlags field bits   enum
  {
  // Bus inquiry PB 

  // scsiFeatureFlags field bits   enum
  {// (internal use, must be nil on entry)   
    scsiBusUltra4SCSI = 0x00000800, // ->     reserved for input          
        0x00000000, // not known whe// -> Length of the entire PB        
        0x000000C0,                 // -> function selector           
// <-     reserved for output          
  // scsiWeirdStuff field bits   enu// <- Returned result               
  {// -> Device Identifier (bus+target+lun)
    scsiOddDisconnectUnsafeRead1 =// -> Callback on completion function     
        0x0001, /* Disconnects on od// -> assorted flags            
                   blind reads */// <> Ptr for driver private use   
    scsiOddDisconnectUnsafeWrite1 =// private field for use in XPT      
        0x0002,                   /*// reserved                    
                                     blind writes */
    scsiBusErrorsUnsafe = 0x0004// <- Number of engines on HBA                
                                // <- Number of transfer types for this HBA 
    scsiRequiresHandshake =
        0x0008,           // <- which data types are supported by this SIM  
                                          cause data corruption */
    scsiTargetDrivenSDTRSafe// <- Size of SCSI_IO PB for this SIM/HBA          
                            // <- Size of max SCSI_IO PB for all SIM/HBAs 
    scsiOddCountForPhysicalUnsafe =
        0x0020, /* If using p// <- Supported features flags field           
                   disconnects must be on even boundries */
    scsiAbortCmdFixed =// <- Version number for the SIM/HBA           
        0x0040, // Set if abort// <- Mimic of INQ byte 7 for the HBA           
        0x0080 // Set if bug al// <- Flags for target mode support           
// <- Scan related feature flags            
  // scsiHBAslotType values   enum
  {// <- Ptr to SIM private data area              
    scsiMotherboardBus = 0x00,  // <- Size of SIM private data area           
// <- Event cap. for Async Callback           
  // Defines for the scsiDriverFlags field (in SCSIDriverPB)   enum
  {// <- Highest path ID in the subsystem         
    scsiDeviceSensitive = 0x// <- ID of the HBA on the SCSI bus           
//                                  
  //  SIMInitInfo PB   // directions are for SCSIRegisterBus call ( -> parm, <- result)              struct SIMInitInfo
  {// <-                                
    Ptr SIMstaticPtr;         /// <- which scsiFlags are supported           
        SIMInterruptPoll;    // -> pointer to the SIM interrupt poll routine          SIMActionUPP NewOldCall; // -> pointer to the SIM NewOldCall routine     UInt16 ioPBSize;         // -> size of SCSI_IO_PBs required for this SIM          Boolean oldCallCapable;  // -> true if this SIM can handle old-API calls     UInt8 simInfoUnused1;    //      reserved                                 long simInternalUse;     // xx not affected or viewed by XPT                   SCSIUPP XPT_ISR;         //    reserved                                 SCSIUPP EnteringSIM;     // <- ptr to the EnteringSIM routine                SCSIUPP ExitingSIM;      // <- ptr to the ExitingSIM routine                   SCSIMakeCallbackUPP
        MakeCallback;    // <- th// <- which scsiIOFlags are supported 
  typedef struct SIMInitInfo SIMI// <-                               
  // Glue between SCSI calls and // <- maximum Target number supported           
  {// <- maximum Logical Unit number supported    
    xptSCSIAction = 0x0001,
    xptSCSIRegisterBus = 0x0002,// <- Vendor ID of SIM (or XPT if bus<FF)        
    xptSCSIDeregisterBus = 0x0003,// <- Vendor ID of the HBA                
    xptSCSIReregisterBus = 0x0004,// <- Family of SCSI Controller           
    xptSCSIKillXPT = 0x0005,   // k// <- Specific Model of SCSI Controller used  

  /**// <- version number of XPT              
   * SCSI bus status. These // <- version number of SIM              
   * phase. They are not rel// <- version number of HBA              
   * other than scsiStatusGood will result in scsiResult set to
   * scsiNonZeroStatus).// <- type of "slot" that this HBA is in       
   */// <- slot number of this HBA                  
  enum// <- resource ID of this SIM                  
  {
    scsiStatGood = 0x00,         // <-                               
// <- additional BusInquiry PB len 
  // SCSI messages  enum
  {
  // Abort SIM Request PB 
    kExtendedMsg = 1,                   // 0x01    kSaveDataPointerMsg = 2,            // 0x02    kRestorePointersMsg = 3,            // 0x03    kDisconnectMsg = 4,                 // 0x04    kInitiatorDetectedErrorMsg = 5,     // 0x05    kAbortMsg = 6,                      // 0x06    kMsgRejectMsg = 7,                  // 0x07    kNoOperationMsg = 8,                // 0x08    kMsgParityErrorMsg = 9,             // 0x09    kLinkedCmdCompleteMsg = 10,         // 0x0a    kLinkedCmdCompleteWithFlagMsg = 11, // 0x0b    kBusDeviceResetMsg = 12,            // 0x0c    kAbortTagMsg = 13,                  // 0x0d    kClearQueueMsg = 14,                // 0x0e    kInitiateRecoveryMsg = 15,          // 0x0f    kReleaseRecoveryMsg = 16,           // 0x10    kTerminateIOProcessMsg = 17,        // 0x11    kSimpleQueueTag = 0x20,             // 0x20    kHeadOfQueueTagMsg = 0x21,          // 0x21    kOrderedQueueTagMsg = 0x22,         // 0x22    kIgnoreWideResidueMsg = 0x23        // 0x23  };

// moveq #kSCSIx, D0;  _SCSIAtomic /// (internal use, must be nil on entry)   
 *  SCSIAction()// ->     reserved for input          
 *// -> Length of the entire PB        
 *  Availability:// -> function selector           
 *    \non_carbon_cfm   in Interface// <-     reserved for output          
 *    \carbon_lib        in CarbonLi// <- Returned result               
 *    \mac_os_x         in version 1// -> Device Identifier (bus+target+lun)
 */// -> Callback on completion function     
#if TARGET_OS_MAC && TARGET_CPU_68K // -> assorted flags            
#pragma parameter __D0 SCSIAction(__// <> Ptr for driver private use   
#endif// private field for use in XPT      
  OSErr// reserved                    
  SCSIAction(SCSI_PB *parameterBlock// Pointer to the PB to abort        

#if CALL_NOT_IN_CARBON
/*// Terminate I/O Process Request PB 
 *  SCSIRegisterBus()
 *
 *  Availability:// (internal use, must be nil on entry)   
 *    \non_carbon_cfm   in Interface// ->     reserved for input          
 *    \carbon_lib        not availab// -> Length of the entire PB        
 *    \mac_os_x         not availabl// -> function selector           
 */// <-     reserved for output          
#if TARGET_OS_MAC && TARGET_CPU_68K // <- Returned result               
#pragma parameter __D0 SCSIRegisterB// -> Device Identifier (bus+target+lun)
#endif// -> Callback on completion function     
  OSErr// -> assorted flags            
  SCSIRegisterBus(SIMInitInfo *param// <> Ptr for driver private use   
// private field for use in XPT      
/**// reserved                    
 *  SCSIDeregisterBus()// Pointer to the PB to terminate        
 *
 *  Availability:
 *// Reset SCSI Bus PB 
 *    \carbon_lib        not available
 *    \mac_os_x         not available
 */// (internal use, must be nil on entry)   
#if TARGET_OS_MAC && TARGET_CPU_68K // ->     reserved for input          
#pragma parameter __D0 SCSIDeregiste// -> Length of the entire PB        
#endif// -> function selector           
  OSErr// <-     reserved for output          
  SCSIDeregisterBus(SCSI_PB *paramet// <- Returned result               
// -> Device Identifier (bus+target+lun)
/**// -> Callback on completion function     
 *  SCSIReregisterBus()// -> assorted flags            
 *// <> Ptr for driver private use   
 *  Availability:// private field for use in XPT      
 *    \non_carbon_cfm   in Interface// reserved                    
 *    \carbon_lib        not available
 *    \mac_os_x         not available
 *// Reset SCSI Device PB 
#if TARGET_OS_MAC && TARGET_CPU_68K && !TARGET_RT_MAC_CFM
#pragma parameter __D0 SCSIReregisterBus(__A0)
#endif// (internal use, must be nil on entry)   
  OSErr// ->     reserved for input          
  SCSIReregisterBus(SIMInitInfo *par// -> Length of the entire PB        
// -> function selector           
/**// <-     reserved for output          
 *  SCSIKillXPT()// <- Returned result               
 *// -> Device Identifier (bus+target+lun)
 *  Availability:// -> Callback on completion function     
 *    \non_carbon_cfm   in Interface// -> assorted flags            
 *    \carbon_lib        not availab// <> Ptr for driver private use   
 *    \mac_os_x         not availabl// private field for use in XPT      
 */// reserved                    
#if TARGET_OS_MAC && TARGET_CPU_68K && !TARGET_RT_MAC_CFM
#pragma parameter __D0 SCSIKillXPT(__A0)
#e// Release SIM Queue PB 
  OSErr
  SCSIKillXPT(SIMInitInfo *parameterBlock) TWOWORDINLINE(0x7005, 0xA089);
// (internal use, must be nil on entry)   
#endif // CALL_NOT_IN_CARBON // ->     reserved for input          
#if PRAGMA_STRUCT_ALIGN// -> Length of the entire PB        
#pragma options align = reset// -> function selector           
#elif PRAGMA_STRUCT_PACKPUSH// <-     reserved for output          
#pragma pack(pop)// <- Returned result               
#elif PRAGMA_STRUCT_PACK// -> Device Identifier (bus+target+lun)
#pragma pack()// -> Callback on completion function     
#endif// -> assorted flags            
// <> Ptr for driver private use   
#ifdef PRAGMA_IMPORT_OFF// private field for use in XPT      
#pragma import off// reserved                    
#elif PRAGMA_IMPORT
#pragma import reset
#e// SCSI Get Virtual ID Info PB 

#ifdef __cplusplus
}// (internal use, must be nil on entry)   
#endif// ->     reserved for input          
// -> Length of the entire PB        
#endif // __SCSI__ cplusplus// -> function selector           
}// <-     reserved for output          
#endif// <- Returned result               
// -> Device Identifier (bus+target+lun)
#endif // __SCSI__ // -> Callback on completion function     
// -> assorted flags            
// <> Ptr for driver private use   
// private field for use in XPT      
// reserved                    
// -> SCSI ID of device in question   
// <- true if device exists        
// Create/Lookup/Remove RefNum for Device PB 
// (internal use, must be nil on entry)   
// ->     reserved for input          
// -> Length of the entire PB        
// -> function selector           
// <-     reserved for output          
// <- Returned result               
// -> Device Identifier (bus+target+lun)
// -> Callback on completion function     
// -> assorted flags            
// <> Ptr for driver private use   
// private field for use in XPT      
// reserved                    
// -> DriverRefNum, For SetDriver, <- For GetNextDriver 
// <> Details of driver/device       
// <- DeviceIdent of the NEXT Item in the list  
// Load Driver PB 
// (internal use, must be nil on entry)   
// ->     reserved for input          
// -> Length of the entire PB        
// -> function selector           
// <-     reserved for output          
// <- Returned result               
// -> Device Identifier (bus+target+lun)
// -> Callback on completion function     
// -> assorted flags            
// <> Ptr for driver private use   
// private field for use in XPT      
// reserved                    
// <- SIM returns refnum of driver      
// -> if true, indicates call after failure to load 
// Defines for the scsiTransferType field 
// 1   = PB request is in progress          
// Execution failed  00-2F 
// -7934 = PB request aborted by the host        
// -7933 = Unable to Abort PB request          
// -7932 = PB request completed with an err   
// -7931 =                        
// -7930 =                        
// -7929 =                        
// -7928 =                        
// -7927 = Unable to Terminate I/O PB req        
// -7926 = Target selection timeout 
// -7925 = Command timeout 
// -7924 = 
// -7923 = Message reject received           
// -7922 = SCSI bus reset sent/received    
// -7921 = Uncorrectable parity error occured     
// -7920 = Autosense: Request sense cmd fail  
// -7919 =                        
// -7918 = Data overrun/underrun error     
// -7917 = Unexpected BUS free 
// -7916 = Target bus phase sequence failure  
// -7915 = Data phase was in wrong direction  
// -7914 =                        
// -7913 = A SCSI BDR msg was sent to target  
// -7912 = PB request terminated by the host  
// -7911 = Nexus is not established 
// -7910 = The SCSI CDB has been received        
// Couldn't begin execution  30-3F 
// -7888 = Register failed because we're full 
// -7887 = SCSI subsystem is busy           
// -7886 = Unable to provide requ. capability 
// -7885 = SCSI device not installed/there    
// -7884 = No HBA detected Error           
// -7883 = sorry, max 1 refNum per DeviceIdent    
// -7882 = no such RefNum xref 
// -7881 = pre-linked PBs not supported      
//   (The QLink field was nonzero)          
// Parameter errors  40-7F 
// -7872 = (scsiPBLength is insuf'ct/invalid  
// -7871 = The requ. func is not available    
// -7870 = PB request is invalid 
// -7869 = Bus ID supplied is invalid 
// -7868 = Target ID supplied is invalid      
// -7867 = LUN supplied is invalid 
// -7866 = The initiator ID is invalid  
// -7865 = scsiDataType requested not supported 
// -7864 = scsiTransferType field is too high     
// -7863 = scsiCDBLength field is too big        
// New errors for SCSI Family         
// -7862 =                          
// -7861 =                          
// -7860 = a zero data length in PB 
// -7859 = could not do full prepare mem for I/O
// -7858 = Invalid message type (internal)       
// -7857 =                              
// -7856 = Bad Connection ID 
// -7855 =                          
// -7854 = Can't close conn, IO in prog      
// -7853 = Target already reserved 
// -7852 =                          
// -7851 =                          
// -7850 = Bad connection type 
// -7849 = No matching service category      
// +++ 
// -7849 = Internal consistency check failed  
// -7848 = Internal consistency check failed  
// ??    = Start of third-party error range     
// Number of third-party errors 
// --- 
// Defines for the scsiResultFlags field 
// The SIM queue is frozen w/this err        
// Autosense data valid for target         
// At time of callback, SCSI bus is not free  
// Disable auto sense feature               
//                             
//                             
// The PB contains a linked CDB             
// Target queue actions are enabled          
// The CDB field contains a pointer          
//                               
// Attempt Sync data xfer and SDTR          
// Disable sync, go to async            
// Place PB at the head of SIM Q          
// Return the SIM Q to frozen state          
// Disallow SIM Q freezing                 
// Definitely do disconnect               
// Definitely don't disconnect              
// Data buffer(s) are ready for DMA          
//                               
// SG/Buffer data ptrs are physical          
// Autosense buffer ptr is physical          
//                               
//                               
//                               
//                               
// Data buffer valid                 
// Status buffer valid                 
// Message buffer valid                
//                             
// Defines for the bit masks of the scsiFlags field 
// Data direction mask 
// Data direction (11: no data) 
// Data direction (00: reserved)       
// Data direction (10: DATA OUT)       
// Data direction (01: DATA IN)          
// Disable auto sense feature          
//                           
//                           
// The PB contains a linked CDB          
// Target queue actions are enabled      
// The CDB field contains a pointer      
//                           
// Attempt Sync data xfer and SDTR 
// Disable sync, go to async          
// Place PB at the head of SIM Q       
// Return the SIM Q to frozen state      
// Disallow SIM Q freezing              
// Definitely do disconnect             
// Definitely don't disconnect          
// Data buffer(s) are ready for DMA      
//  
// SG/Buffer data ptrs are physical      
// Autosense buffer ptr is physical      
//                         
//                           
//                           
//                           
// bit masks for the scsiIOFlags field in SCSIExecIOPB 
// disable parity checking                 
// disable select w/Atn                    
// do SaveDataPointer upon Disconnect msg 
// don�t bit bucket in during this I/O           
// don�t bit bucket out during this I/O        
// disable wide transfer negotiation           
// initiate wide transfer negotiation           
// renegotiate sync/wide before issuing autosense     
// disable parameter checking on SCSIExecIO calls 
//                                
//                                  
// Defines for the Bus Inquiry PB fields. 
// scsiHBAInquiry field bits 
// Supports Modify Data Pointer message               
// Supports 32 bit wide SCSI                    
// Supports 16 bit wide SCSI                    
// Supports Sync Data Transfer Req message              
// Supports linked CDBs                         
// Supports tag queue message                    
// Supports soft reset                           
// Defines for the scsiDataType field 
// single contiguous buffer supplied            
// TIB supplied (ptr in scsiDataPtr)           
// scatter/gather list supplied             
// scsiDataTypes field bits  
//  bits 0->15 Apple-defined, 16->30 3rd-party unique, 31 = reserved 
// TIB supplied (ptr in scsiDataPtr)   
// single contiguous buffer supplied      
// scatter/gather list supplied        
// (2/6/95) Prepare Memory for IO
//                            
// scsiScanFlags field bits 
// Bus scans for and maintains device list 
// Bus scans performed at power-up/reboot        
// may load ROM drivers to support targets 
// scsiFeatureFlags field bits 
// HBA supports Ultra4(Ultra320) SCSI 
// HBA is Low Voltage Differential Bus         
// HBA supports Ultra3 SCSI               
// HBA supports Ultra2 SCSI               
// bus internal/external mask 
// not known whether bus is inside or outside     
// bus goes inside and outside the box       
// bus goes inside the box                
// bus goes outside the box             
// DMA is cache coherent 
// SIM is old call capable   
// HBA supports Ultra SCSI                 
// Single Ended (0) or Differential (1) 
// HBA supports fast SCSI                  
// DMA is available                  
// scsiWeirdStuff field bits 
// Set if abort command is fixed to properly make callbacks 
// Set if bug allowing Mesh to release ACK prematurely is fixed 
// scsiHBAslotType values 
// A built in Apple supplied bus            
// A SIM on a NuBus card                   
//    "  on a PDS card                    
//    "  on a PCI bus card                   
//    "  on a PCMCIA card                  
//    "  connected through a FireWire bridge 
//    "  connected on a USB bus               
// Defines for the scsiDriverFlags field (in SCSIDriverPB) 
// Only driver should access this device      
// no old call access to this device 
//  SIMInitInfo PB 
// directions are for SCSIRegisterBus call ( -> parm, <- result)            
// <- alloc. ptr to the SIM's static vars           
// -> num bytes SIM needs for static vars           
// -> pointer to the SIM init routine               
// -> pointer to the SIM action routine           
//      reserved                           
// -> pointer to the SIM interrupt poll routine      
// -> pointer to the SIM NewOldCall routine 
// -> size of SCSI_IO_PBs required for this SIM      
// -> true if this SIM can handle old-API calls 
//      reserved                             
// xx not affected or viewed by XPT               
//    reserved                             
// <- ptr to the EnteringSIM routine            
// <- ptr to the ExitingSIM routine               
// <- the XPT layer�s SCSIMakeCallback routine            
// <- bus number for the registered bus             
// <- Magic cookie to place in scsiHBASlotNumber (PCI) 
// <- Magic cookie to place in scsiSIMsRsrcID  (PCI)  
// -> The SIM's RegEntryIDPtr            (PCI)  
// Glue between SCSI calls and SCSITrap format 
// kills Mini-XPT after transition 
// Initialize the SCSI manager 
// Good Status
// Check Condition
// Condition Met
// Busy
// Intermediate
// Intermediate - Condition Met
// Reservation conflict
// Command terminated
// Queue full
// SCSI messages
// 0x01
// 0x02
// 0x03
// 0x04
// 0x05
// 0x06
// 0x07
// 0x08
// 0x09
// 0x0a
// 0x0b
// 0x0c
// 0x0d
// 0x0e
// 0x0f
// 0x10
// 0x11
// 0x20
// 0x21
// 0x22
// 0x23
// moveq #kSCSIx, D0;  _SCSIAtomic 
// CALL_NOT_IN_CARBON 
// __SCSI__ 
// __SCSI__ 
